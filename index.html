<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Skateboard Tool (Module Version)</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    #gui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 4px;
      max-width: 250px;
      z-index: 10;
    }
    label { display: block; margin-bottom: 8px; font-size: 0.9em; }
    input[type="range"] { width: 100%; }
    button {
      margin-top: 10px;
      padding: 6px 12px;
      font-size: 0.9em;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="gui">
    <!-- Example slider controls -->
    <label>
      Body Front Width (in): <span id="bodyWidthNoseVal">8.5</span>
      <input type="range" id="bodyWidthNose" min="1" max="10" step="0.125" value="8.5">
    </label>
    <label>
      Body Back Width (in): <span id="bodyWidthTailVal">8.5</span>
      <input type="range" id="bodyWidthTail" min="1" max="10" step="0.125" value="8.5">
    </label>
    <label>
      Nose Length (in): <span id="noseLengthVal">5.5</span>
      <input type="range" id="noseLength" min="3" max="6" step="0.125" value="5.5">
    </label>
    <label>
      Tail Length (in): <span id="tailLengthVal">5.5</span>
      <input type="range" id="tailLength" min="3" max="6" step="0.125" value="5.5">
    </label>
    <label>
      Nose Curvature: <span id="noseCurvatureVal">40</span>
      <input type="range" id="noseCurvature" min="0" max="50" step="1" value="40">
    </label>
    <label>
      Body Curvature: <span id="bodyCurvatureVal">45</span>
      <input type="range" id="bodyCurvature" min="-50" max="50" step="1" value="45">
    </label>
    <label>
      Tail Curvature: <span id="tailCurvatureVal">40</span>
      <input type="range" id="tailCurvature" min="0" max="50" step="1" value="40">
    </label>
    <label>
      Nose Control Pos: <span id="noseCtrlPosVal">0.96</span>
      <input type="range" id="noseCtrlPos" min="0" max="1" step="0.01" value="0.96">
    </label>
    <label>
      Body Control Pos: <span id="bodyCtrlPosVal">0.5</span>
      <input type="range" id="bodyCtrlPos" min="0" max="1" step="0.01" value="0.5">
    </label>
    <label>
      Tail Control Pos: <span id="tailCtrlPosVal">0.96</span>
      <input type="range" id="tailCtrlPos" min="0" max="1" step="0.01" value="0.96">
    </label>
    <button id="updateButton">Update Shape</button>
  </div>

  <script type="module">
    // Import Three.js and OrbitControls as modules
    import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';
    import { OrbitControls } from 'https://threejs.org/examples/jsm/controls/OrbitControls.js';

    let scene, camera, renderer, controls;
    let boardMesh;

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f8ff);

      const aspect = window.innerWidth / window.innerHeight;
      camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
      camera.position.set(20, 20, 40);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      scene.add(new THREE.AmbientLight(0x888888));
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(0, 50, 50);
      scene.add(directionalLight);

      // Add an AxesHelper to visualize the scene orientation
      scene.add(new THREE.AxesHelper(10));

      // Use imported OrbitControls
      controls = new OrbitControls(camera, renderer.domElement);

      boardMesh = createBoardShape();
      scene.add(boardMesh);

      // Update slider labels on input
      document.querySelectorAll('#gui input').forEach(input => {
        input.addEventListener('input', (e) => {
          const span = document.getElementById(e.target.id + 'Val');
          if (span) span.textContent = e.target.value;
        });
      });

      document.getElementById('updateButton').addEventListener('click', updateBoardShape);
      window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    function updateBoardShape() {
      scene.remove(boardMesh);
      boardMesh.geometry.dispose();
      boardMesh.material.dispose();
      boardMesh = createBoardShape();
      scene.add(boardMesh);
    }

    function createBoardShape() {
      // Read parameters (in inches)
      const bodyWidthNose = parseFloat(document.getElementById('bodyWidthNose').value);
      const bodyWidthTail = parseFloat(document.getElementById('bodyWidthTail').value);
      const noseLength = parseFloat(document.getElementById('noseLength').value);
      const tailLength = parseFloat(document.getElementById('tailLength').value);
      const noseCurvature = parseFloat(document.getElementById('noseCurvature').value);
      const bodyCurvature = parseFloat(document.getElementById('bodyCurvature').value);
      const tailCurvature = parseFloat(document.getElementById('tailCurvature').value);
      const noseCtrlPos = parseFloat(document.getElementById('noseCtrlPos').value);
      const bodyCtrlPos = parseFloat(document.getElementById('bodyCtrlPos').value);
      const tailCtrlPos = parseFloat(document.getElementById('tailCtrlPos').value);

      // Define fixed lengths (in inches)
      const bodyLength = 22;
      const noseStart = 6;
      const tailStart = noseStart + bodyLength;

      // Build a 2D shape (upper half of the board)
      const shape = new THREE.Shape();
      shape.moveTo(noseStart - noseLength, 0);
      const noseCPx = noseStart - noseLength * noseCtrlPos;
      const noseCPy = (bodyWidthNose / 2) - (noseCurvature / 50) * (bodyWidthNose);
      shape.quadraticCurveTo(noseCPx, noseCPy, noseStart, bodyWidthNose / 2);

      const bodyCPx = noseStart + bodyCtrlPos * bodyLength;
      const bodyCPy = ((bodyWidthNose / 2) + (bodyWidthTail / 2)) / 2 - (bodyCurvature / 50) * ((bodyWidthNose + bodyWidthTail) / 2);
      shape.quadraticCurveTo(bodyCPx, bodyCPy, tailStart, bodyWidthTail / 2);

      const tailCPx = tailStart + tailLength * tailCtrlPos;
      const tailCPy = (bodyWidthTail / 2) - (tailCurvature / 50) * (bodyWidthTail);
      shape.quadraticCurveTo(tailCPx, tailCPy, tailStart + tailLength, 0);

      // Mirror for lower half
      shape.lineTo(tailStart + tailLength, 0);
      shape.quadraticCurveTo(tailCPx, -tailCPy, tailStart, -bodyWidthTail / 2);
      shape.quadraticCurveTo(bodyCPx, -bodyCPy, noseStart, -bodyWidthNose / 2);
      shape.quadraticCurveTo(noseCPx, -noseCPy, noseStart - noseLength, 0);

      const extrudeSettings = {
        steps: 2,
        depth: 2,
        bevelEnabled: true,
        bevelThickness: 0.2,
        bevelSize: 0.2,
        bevelOffset: 0,
        bevelSegments: 2
      };

      const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      geometry.center();

      const material = new THREE.MeshPhongMaterial({ 
        color: 0x8B4513, 
        shininess: 50,
        side: THREE.DoubleSide
      });
      return new THREE.Mesh(geometry, material);
    }
  </script>
</body>
</html>
