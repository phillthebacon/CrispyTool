<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Skateboard Shape Tool</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    #gui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 4px;
      max-width: 250px;
      z-index: 10;
    }
    label {
      display: block;
      margin-bottom: 8px;
      font-size: 0.9em;
    }
    input[type="range"] { width: 100%; }
    button {
      margin-top: 10px;
      padding: 6px 12px;
      font-size: 0.9em;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="gui">
    <label>
      Body Front Width (in): <span id="bodyWidthNoseVal">8.5</span>
      <input type="range" id="bodyWidthNose" min="1" max="10" step="0.125" value="8.5">
    </label>
    <label>
      Body Back Width (in): <span id="bodyWidthTailVal">8.5</span>
      <input type="range" id="bodyWidthTail" min="1" max="10" step="0.125" value="8.5">
    </label>
    <label>
      Nose Length (in): <span id="noseLengthVal">5.5</span>
      <input type="range" id="noseLength" min="3" max="6" step="0.125" value="5.5">
    </label>
    <label>
      Tail Length (in): <span id="tailLengthVal">5.5</span>
      <input type="range" id="tailLength" min="3" max="6" step="0.125" value="5.5">
    </label>
    <label>
      Nose Curvature: <span id="noseCurvatureVal">40</span>
      <input type="range" id="noseCurvature" min="0" max="50" step="1" value="40">
    </label>
    <label>
      Body Curvature: <span id="bodyCurvatureVal">45</span>
      <input type="range" id="bodyCurvature" min="-50" max="50" step="1" value="45">
    </label>
    <label>
      Tail Curvature: <span id="tailCurvatureVal">40</span>
      <input type="range" id="tailCurvature" min="0" max="50" step="1" value="40">
    </label>
    <label>
      Nose Control Pos: <span id="noseCtrlPosVal">0.96</span>
      <input type="range" id="noseCtrlPos" min="0" max="1" step="0.01" value="0.96">
    </label>
    <label>
      Body Control Pos: <span id="bodyCtrlPosVal">0.5</span>
      <input type="range" id="bodyCtrlPos" min="0" max="1" step="0.01" value="0.5">
    </label>
    <label>
      Tail Control Pos: <span id="tailCtrlPosVal">0.96</span>
      <input type="range" id="tailCtrlPos" min="0" max="1" step="0.01" value="0.96">
    </label>
    <button id="updateButton">Update Shape</button>
  </div>

  <!-- Three.js Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- OrbitControls for drag-to-rotate -->
  <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
  <script>
    let scene, camera, renderer, controls;
    let boardMesh;

    init();
    animate();

    function init() {
      // Create scene and set background color
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f8ff);

      // Set up camera
      const aspect = window.innerWidth / window.innerHeight;
      camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
      camera.position.set(0, 20, 40);

      // Set up renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Add some lights
      scene.add(new THREE.AmbientLight(0x888888));
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(0, 50, 50);
      scene.add(directionalLight);

      // Add OrbitControls for interactive rotation
      controls = new THREE.OrbitControls(camera, renderer.domElement);

      // Create and add the initial board mesh
      boardMesh = createBoardShape();
      scene.add(boardMesh);

      // Update UI labels as the slider values change
      document.querySelectorAll('#gui input').forEach(input => {
        input.addEventListener('input', (e) => {
          const id = e.target.id;
          const span = document.getElementById(id + 'Val');
          if (span) span.textContent = e.target.value;
        });
      });

      // Button to update (re-create) the board mesh
      document.getElementById('updateButton').addEventListener('click', updateBoardShape);

      // Handle window resize
      window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    // Remove the old mesh and add a new one
    function updateBoardShape() {
      scene.remove(boardMesh);
      boardMesh.geometry.dispose();
      boardMesh.material.dispose();
      boardMesh = createBoardShape();
      scene.add(boardMesh);
    }

    // This function builds the board shape using a 2D THREE.Shape and then extrudes it
    function createBoardShape() {
      // Read parameters (all in inches)
      const bodyWidthNose = parseFloat(document.getElementById('bodyWidthNose').value);
      const bodyWidthTail = parseFloat(document.getElementById('bodyWidthTail').value);
      const noseLength = parseFloat(document.getElementById('noseLength').value);
      const tailLength = parseFloat(document.getElementById('tailLength').value);
      const noseCurvature = parseFloat(document.getElementById('noseCurvature').value);
      const bodyCurvature = parseFloat(document.getElementById('bodyCurvature').value);
      const tailCurvature = parseFloat(document.getElementById('tailCurvature').value);
      const noseCtrlPos = parseFloat(document.getElementById('noseCtrlPos').value);
      const bodyCtrlPos = parseFloat(document.getElementById('bodyCtrlPos').value);
      const tailCtrlPos = parseFloat(document.getElementById('tailCtrlPos').value);

      // Define fixed lengths (in inches)
      const bodyLength = 22; // fixed body section length
      const noseStart = 6;   // x-position where the body begins (similar to the 2D tool)
      const tailStart = noseStart + bodyLength;

      // Create a 2D shape for the board outline (upper half)
      const shape = new THREE.Shape();
      // Nose: start at the tip (assumed centered at y=0) and curve to the start of the body.
      shape.moveTo(noseStart - noseLength, 0);
      // Control point for nose curve
      const noseCPx = noseStart - noseLength * noseCtrlPos;
      // Adjust the control pointâ€™s y based on curvature (the factor here is adjustable)
      const noseCPy = (bodyWidthNose / 2) - (noseCurvature / 50) * (bodyWidthNose);
      shape.quadraticCurveTo(noseCPx, noseCPy, noseStart, bodyWidthNose / 2);

      // Body: curve from the nose-body junction to the tail-body junction
      const bodyCPx = noseStart + bodyCtrlPos * bodyLength;
      const bodyCPy = ((bodyWidthNose / 2) + (bodyWidthTail / 2)) / 2 - (bodyCurvature / 50) * ((bodyWidthNose + bodyWidthTail) / 2);
      shape.quadraticCurveTo(bodyCPx, bodyCPy, tailStart, bodyWidthTail / 2);

      // Tail: curve from the body end to the tail tip (centered at y=0)
      const tailCPx = tailStart + tailLength * tailCtrlPos;
      const tailCPy = (bodyWidthTail / 2) - (tailCurvature / 50) * (bodyWidthTail);
      shape.quadraticCurveTo(tailCPx, tailCPy, tailStart + tailLength, 0);

      // Mirror the outline for the bottom half by retracing in reverse order
      shape.lineTo(tailStart + tailLength, 0); // Already at tail tip
      shape.quadraticCurveTo(tailCPx, -tailCPy, tailStart, -bodyWidthTail / 2);
      shape.quadraticCurveTo(bodyCPx, -bodyCPy, noseStart, -bodyWidthNose / 2);
      shape.quadraticCurveTo(noseCPx, -noseCPy, noseStart - noseLength, 0);

      // Extrude the shape to add thickness (in inches)
      const extrudeSettings = {
        steps: 2,
        depth: 0.5, // thickness of the board
        bevelEnabled: true,
        bevelThickness: 0.1,
        bevelSize: 0.1,
        bevelOffset: 0,
        bevelSegments: 1
      };

      const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      // Center the geometry in the scene
      geometry.center();

      // Create a mesh with a wood-like material
      const material = new THREE.MeshPhongMaterial({ color: 0x8B4513, shininess: 50 });
      return new THREE.Mesh(geometry, material);
    }
  </script>
</body>
</html>
